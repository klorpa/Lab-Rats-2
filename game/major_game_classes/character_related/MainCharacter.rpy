init -2 python:
    class MainCharacter(renpy.store.object):
        def __init__(self, location, name, last_name, business, stat_array, skill_array, sex_array):
            self.location = location
            self.name = name
            self.last_name = last_name
            self.energy = 50
            self.designed_wardrobe = Wardrobe("Designed Wardrobe")
            self.business = business
            self.inventory = SerumInventory()

            ##Mental stats##
            #Mental stats are generally fixed and cannot be changed permanently.
            self.charisma = stat_array[0]#How likeable the person is. Mainly influences marketing, also determines how well interactions with other characters go. Main stat for HR and sales
            self.int = stat_array[1] #How smart the person is. Mainly influences research, small bonuses to most tasks. #Main stat for research and production.
            self.focus = stat_array[2]#How on task the person stays. Influences most tasks slightly. #Main stat for supplies

            ##Work Skills##
            #Skills can be trained up over time, but are limited by your raw stats.
            self.hr_skill = skill_array[0]
            self.market_skill = skill_array[1]
            self.research_skill = skill_array[2]
            self.production_skill = skill_array[3]
            self.supply_skill = skill_array[4]

            ##Sex Stats##
            # These are phyical stats about the character that impact how they behave in a sex scene. Future values might include penis size or sensitivity.
            self.arousal = 0 #How close to an orgasm you are. You cum when you reawch your max_arousal, default 100.
            self.max_arousal = 100

            self.masturbation_novelty = 100 #How novel masturbation is. As something becomes less Novel you convert clarity less efficently.
            self.locked_clarity = 0 #Clarity generated by events, but not yet released by cumming.
            self.free_clarity = 0 #Clarity unlocked by cumming, availble for use unlocking serum traits.

            ##Sex Skills##
            # These skill represent your knowledge and experience with different types of intimacy. Useful for raising a girls arousal faster than your own.
            self.sex_skills = {}
            self.sex_skills["Foreplay"] = sex_array[0] # A catch all for everything that goes on before blowjobs, sex, etc. Includes things like kissing, massages, etc.
            self.sex_skills["Oral"] = sex_array[1] # Your skill at eating a girl out.
            self.sex_skills["Vaginal"] = sex_array[2] # Your skill at different positions that involve vaginal sex.
            self.sex_skills["Anal"] = sex_array[3] # Your skill skill at different positions that involve anal sex.
            #
            # self.max_stamina = 2 # How many times you can seduce someone each day
            # self.current_stamina = 2 # Current stamina.

            self.max_energy = 100 #Your physical energy. Mainly consumed by having sex, slowly comes back during the day (with some actions speeding this up), and a lot of it returns at the end of the day
            self.energy = self.max_energy

            self.main_character_actions = [] # A list of actions enabld for the main character when they talk to people. Kind of like a "role" for the MC.

            self.condom = False #True if you currently have a condom on. (maintained by sex scenes). TODO: Allow a third "broken" state and add dialgoue and descriptions for that.
            self.recently_orgasmed = False #If True you recently orgasmsed and aren't hard until your arousal rises to 10 or the encounter ends.

            self.known_home_locations = [] #When the MC learns a character's home location the room reference should be added here. They can then get to it from the map.

            self.having_text_conversation = None #Set to a Person when dialogue should be taking place on the phone. Logs dialogue (but not narration) as appropriate.
            self.text_conversation_paused = False #Shows the say window as normal for all dialogue with the phone display underneath if having_text_conversation is set to a Person

            self.phone = TextMessageManager()

            self.listener_system = ListenerManagementSystem() #A listener manager to let us enroll to events and update goals when they are triggered.

            #How many free points does the main character have to spend on their skills/abilities
            self.free_stat_points = 0
            self.free_work_points = 0
            self.free_sex_points = 0

            #The maximum score you can have in each of the major skill catagories
            self.max_stats = 8
            self.max_work_skills = 8
            self.max_sex_skills = 8
            self.max_energy_cap = 200

            #The current goals set for the player to achieve. On completion they gain 1 point towards that class of skills
            self.stat_goal = None
            self.work_goal = None
            self.sex_goal = None

            #The difficulty of goals. Some goals will be removed once the difficulty is highe enough, others will be added, and some will have completion requirements based on the difficulty.
            self.stat_goal_difficulty = 0
            self.work_goal_difficulty = 0
            self.sex_goal_difficulty = 0

            self.clarity_purchase_level = 0 #Increased by 1 every time you buy a stat with Clarity.
            # Each level costs 50*(2^level)

            self.log_items = [] #A list of items to display as a log. is a tuple of: [string_to_display, text_style, unix_time]
            self.log_max_size = 20

            self.scrap_goal_available = True

            self.can_skip_time = False #A flag used to determine when it is safe to skip time and when it is not. Left in as of v0.19.0 to ensure missed references do not cause a crash; has no function.

            self.stolen_underwear = {} #Person should be a key, and should hold a list of clothing that has been taken by the MC.
            self.event_triggers_dict = {} #General purpose dict for storing event flags related to the MC.


        def change_location(self,new_location): #TODO: Check if we can add the "show_background" command for our new location here. Is there any time where we want to be in a location but _not_ show it's background?
            if isinstance(new_location, Room):
                self.location = new_location

        def change_arousal(self,amount):
            self.arousal += amount
            if self.arousal < 0:
                self.arousal = 0

        def reset_arousal(self):
            self.arousal = 0

        def change_energy(self, amount, add_to_log = True):
            amount = __builtin__.round(amount)
            self.energy += amount
            if self.energy > self.max_energy:
                self.energy = self.max_energy
            elif self.energy < 0:
                self.energy = 0

            log_string = ""
            if amount  > 0:
                log_string += "You: +" + str(amount)  + " Energy"
            else:
                log_string += "You: " + str(amount)  + " Energy"
            if add_to_log and amount != 0:
                mc.log_event(log_string, "float_text_yellow")
            return

        def change_max_energy(self, amount, add_to_log = True):
            amount = __builtin__.round(amount)
            self.max_energy += amount
            if self.max_energy < 0:
                self.max_energy = 0

            if self.energy > self.max_energy: #No having more energy than max in case we lower max
                self.energy = self.max_energy

            log_string = ""
            if amount > 0:
                log_string += "You: +" + str(amount) + " Max Energy"
            else:
                log_string += "You: " + str(amount) + " Max Energy"
            if add_to_log and amount != 0:
                mc.log_event(log_string, "float_text_yellow")
            return

        def change_masturbation_novelty(self, amount, add_to_log = True):
            amount = __builtin__.round(amount)
            if amount + self.masturbation_novelty > 100:
                amount = 100 - self.masturbation_novelty

            elif amount + self.masturbation_novelty < 50:
                amount = -(self.masturbation_novelty - 50)

            self.masturbation_novelty += amount

            log_string = ""
            if amount > 0:
                log_string += "You: +" + str(amount) + " Masturbation Novelty"
            else:
                log_string += "You: " + str(amount) + " Masturbation Novelty"
            if add_to_log and amount != 0:
                mc.log_event(log_string, "float_text_yellow")

        def change_locked_clarity(self, amount, add_to_log = True): #TODO: Decide if we need a max locked clarity thing to gate progress in some way.
            amount = int(__builtin__.round(amount))
            self.locked_clarity += amount
            log_string = ""
            if amount > 0:
                log_string += "You: +" + str(amount) + " Locked Clarity"
            else:
                log_string += "You: " + str(amount) + " Locked Clarity"
            if add_to_log and amount != 0:
                mc.log_event(log_string, "float_text_blue")

                effect_strength = (amount/80.0) + 0.4
                if effect_strength > 1.0:
                    effect_strength = 1.0
                renpy.show_screen("border_pulse", effect_strength, _transient = True)
            return

        def convert_locked_clarity(self, conversion_multiplier = 1.0, with_novelty = None, add_to_log = True): #TODO: Decide if clarity should decay over time.
            amount = self.locked_clarity * conversion_multiplier
            if with_novelty:
                amount = amount * (with_novelty/100.0) #NOTE: Novelty is a score from 50 to 100, but is often treated as a percent.
            amount = int(__builtin__.round(amount))
            self.locked_clarity = 0

            self.free_clarity += amount
            log_string = ""
            log_string += "You: " + str(amount) + " Clarity Released!"
            if with_novelty and with_novelty < 100:
                log_string += "\n{}% lost due to low Novelty.".format(100-with_novelty)
            if add_to_log and amount != 0:
                mc.log_event(log_string, "float_text_blue")
                renpy.show_screen("cum_screen", _transient = True)
            return

        def spend_clarity(self, amount, add_to_log = False):
            amount = int(__builtin__.round(amount))
            if amount < 0: #No spending negative clarity.
                return

            if amount > self.free_clarity:
                amount = self.free_clarity

            self.free_clarity += -amount
            log_string = "You: Spent " + str(amount) + " Clarity"
            if add_to_log and amount != 0:
                mc.log_event(log_string, "float_text_blue")
            return

        def add_clarity(self, amount, add_to_log = True): #Adds a flat amount of Clarity, without interacting with Locked Clarity. Used when an outside influence generates Clarity.
            amount = int(__builtin__.round(amount))
            if amount < 0:
                return

            self.free_clarity += amount

            log_string = "You: received " + str(amount) + " Clarity"
            if add_to_log and amount != 0:
                mc.log_event(log_string, "float_text_blue")
            return

        def save_design(self, the_outfit, new_name, outfit_type = "full"):
            the_outfit.name = new_name
            if outfit_type == "under":
                self.designed_wardrobe.add_underwear_set(the_outfit)
            elif outfit_type == "over":
                self.designed_wardrobe.add_overwear_set(the_outfit)
            else: #Generally outfit_type == full, or some other uncaught error.
                self.designed_wardrobe.add_outfit(the_outfit)

        def is_at_work(self): #Checks to see if the main character is at work, generally used in crisis checks.
            if self.location == self.business.m_div or self.location == self.business.p_div or self.location == self.business.r_div or self.location == self.business.s_div or self.location == self.business.h_div:
                return True
            else:
                return False

        def run_turn(self):
            self.listener_system.fire_event("time_advance")
            self.change_arousal(-20)
            self.change_energy(20)
            return

        def run_day(self):
            self.listener_system.fire_event("end_of_day")
            self.change_energy(60)
            self.change_masturbation_novelty(1, add_to_log = False)

            self.reset_arousal()
            self.scrap_goal_available = True

        def complete_goal(self, the_finished_goal):
            if the_finished_goal == self.stat_goal:
                self.free_stat_points += 1 #The player gets some new points to spend
                self.stat_goal_difficulty += 1 #Future goals become more difficult
                self.stat_goal = create_new_stat_goal(self.stat_goal_difficulty) #Generate a new goal

            elif the_finished_goal == self.work_goal:
                self.free_work_points += 1
                self.work_goal_difficulty += 1
                self.work_goal = create_new_work_goal(self.work_goal_difficulty)

            elif the_finished_goal == self.sex_goal:
                self.free_sex_points += 1
                self.sex_goal_difficulty += 1
                self.sex_goal = create_new_sex_goal(self.sex_goal_difficulty)

        def scrap_goal(self, the_finished_goal):
            if the_finished_goal == self.stat_goal:
                self.stat_goal = create_new_stat_goal(self.stat_goal_difficulty) #Generate a new goal

            elif the_finished_goal == self.work_goal:
                self.work_goal = create_new_work_goal(self.work_goal_difficulty)

            elif the_finished_goal == self.sex_goal:
                self.sex_goal = create_new_sex_goal(self.sex_goal_difficulty)

            self.scrap_goal_available = False

        def generate_goals(self):
            self.stat_goal = create_new_stat_goal(self.stat_goal_difficulty)
            self.work_goal = create_new_work_goal(self.work_goal_difficulty)
            self.sex_goal = create_new_sex_goal(self.sex_goal_difficulty)

        def buy_point(self, stat_string, clarity_cost = 0):
            if stat_string == "stat":
                self.free_stat_points += 1

            elif stat_string == "work":
                self.free_work_points += 1

            elif stat_string == "sex":
                self.free_sex_points += 1

            self.clarity_purchase_level += 1
            self.spend_clarity(clarity_cost)

        def buy_point_cost(self):
            point_cost = 50 * (2**(self.clarity_purchase_level/2.0))
            return point_cost

        def improve_stat(self, stat_string, amount = 1):
            if amount > self.free_stat_points:
                amount = self.free_stat_points
            if stat_string == "int":
                self.int += amount
            elif stat_string == "cha":
                self.charisma += amount
            elif stat_string == "foc":
                self.focus += amount

            self.free_stat_points += -amount

        def improve_work_skill(self, skill_string, amount = 1):
            if amount > self.free_work_points:
                amount = self.free_work_points

            if skill_string == "hr":
                self.hr_skill += amount
            elif skill_string == "market":
                self.market_skill += amount
            elif skill_string == "research":
                self.research_skill += amount
            elif skill_string == "production":
                self.production_skill += amount
            elif skill_string == "supply":
                self.supply_skill += amount

            self.free_work_points += -amount

        def improve_sex_skill(self, sex_string, amount = 1):
            if amount > self.free_sex_points:
                amount = self.free_sex_points

            if sex_string in self.sex_skills:
                self.sex_skills[sex_string] += amount
            elif sex_string == "stam":
                self.energy += amount * 20
                self.max_energy += amount * 20

            self.free_sex_points += -amount


        def log_event(self, the_text, the_text_style):
            if the_text is None: # Make sure we're not passing None items accidentily, which could cause crashes for the main hud.
                the_text = "???"
            if the_text_style is None:
                the_text_style = "float_text_grey"

            event_tuple = (the_text, the_text_style, time.time()) #Stores the unix time the event was added so we can run a little animation.
            self.log_items.insert(0,event_tuple)
            while len(self.log_items) > self.log_max_size:
                self.log_items.pop() #Pop off extra items until we are down to size.

        def start_text_convo(self, the_person): #Triggers all the appropriate variables so say entries will go into the phone text log.
            self.phone.register_number(the_person)
            self.having_text_conversation = the_person
            self.text_conversation_paused = False
            return

        def end_text_convo(self): #Resets all triggers from texting someone, so say messages are displayed properly again, ect.
            self.having_text_conversation = None
            self.text_conversation_paused = False
            return

        def pause_text_convo(self): #Keeps the phone UI and display up, but your dialogue and dialogue from any girl other than the one you're texting will display as normal and not be logged.
            self.text_conversation_paused = True #TODO: We no longer need to give characters a specific phone font, because it all goes right into the phone log itself. Otherwise this breaks the MC dialogue.
            return

        def resume_text_convo(self): #Start hiding the phone UI again. Use after you have paused a text convo
            self.text_conversation_paused = False
            return

        # def log_text_message(self, the_person, the_message):
        #     #TODO: Allow you to insert arbitrary messages by building history entries here! Use this for a narrator sytle "[Sent a picture]"!
        #     return

        def steal_underwear(self, the_person, the_item): #TODO: Add unit tests. TODO: Add ability to clear items out of the list. #TODO: Add ability to check if a similar item already exists in your collection.
            if not the_person in self.stolen_underwear:
                self.stolen_underwear[the_person] = []

            self.stolen_underwear[the_person].append(the_item)

        def get_underwear_list(self): #Returns a list of tuples. First item is the common display name "PERSON's ITEM", the second is the item reference itself #TODO: Add unit tests
            return_list = []
            for person in self.stolen_underwear:
                for item in self.stolen_underwear[person]:
                    return_list.append([person.title + "'s " + item.display_name, item]) #TODO: Write the display code for this so it can show the little set of panties or bra with the correct colour/pattern. #TODO: might need an "empty" body type.

            return return_list
